---
title: 1. 스프링 빈 활용
---

# 스프링 빈 활용

## 개요

- 요구사항: 문자열을 출력하는 빈을 만들자. 이 빈은 방향성을 설정할 수 있다. 콘솔로도, 파일로도, DB로도 출력할 수 있도록 한다.
- 구현 방향: 전략 패턴을 사용한다.
    - 해당 빈의 세부 기능 각각이 하나의 전략이 되게 설계한다.
        - Console 출력
        - File 출력
    - 빈 자체와 전략 사이에는 인터페이스를 위치시켜 연결고리 기능을 수행하도록 한다.

> **전략 패턴**  
> 
> 상속을 사용하지 않고, 기능 로직 중 일부를 외부로 분리시키는 패턴

## 실습: sample 6

```java
//smaple6.Output

package springioc.sample6;

public interface Output {

	void print(String message) throws Exception;
}

```

연결고리 역할을 해주는 인터페이스를 작성하였다. 이제 이 인터페이스를 구현하여 각 전략을 만든다.

```java
// sample6.FileOutput
package springioc.sample6;

import java.io.File;
import java.io.FileWriter;

public class FileOutput implements Output {

	private String filePath;
	
	public FileOutput() {
		System.out.println("[FileOutput] 기본 생성자 호출됨");
	}
	
	public FileOutput(String filePath) {
		super();
		this.filePath = filePath;
		System.out.println("[FileOutput] 생성자 호출됨: " + filePath);
	}

	public void setFilePath(String filePath) {
		this.filePath = filePath;
		System.out.println("[FileOutput] 세터 호출됨: " + filePath);
	}

	@Override
	public void print(String message) throws Exception {
		System.out.println("[FileOutput] print 메서드 호출됨: " + message);
		
		FileWriter out = new FileWriter(filePath); // PrintWriter와 비슷. 파일로 향하는 스트림
		out.write(message);
		out.close();
		
		System.out.println("[FileOutput] print 메서드 종료됨: " + message + "@" + filePath);
	}
}

```

```java
// sample6.ConsoleOutput
package springioc.sample6;

public class ConsoleOutput implements Output {

	public ConsoleOutput() {
		System.out.println("[ConsoleOutput] 기본 생성자 호출됨");
	}
	
	@Override
	public void print(String message) throws Exception {
		System.out.println("[ConsoleOutput] print 메서드 호출됨: " + message);
		System.out.println(message);
	}
}

```

빈 역시 나중의 확장을 대비하여 인터페이스를 먼저 만들고 이를 구현하는 방식으로 작성한다.

```java
// sample6.MessageBean
package springioc.sample6;

public interface MessageBean {

	void sayHello();
}

```

```java
// sample6.MessageBeanImpl
package springioc.sample6;

public class MessageBeanImpl implements MessageBean {

	private String name;
	private String phone;
	private Output output; // 전략을 받을 인터페이스를 필드로 갖는다.
	
	public MessageBeanImpl() {
		System.out.println("[MessageBeanImpl] 기본 생성자 호출됨");
	}

	public MessageBeanImpl(String name) { // 여러 상황을 연습해보기 위해 이름만 생성자로 받는다
		this.name = name;
		System.out.println("[MessageBeanImpl]  생성자 호출됨: " + name);
	}


	// 나머지 필드는 세터로 입력받을 것이다
	
	public void setPhone(String phone) {
		this.phone = phone;
		System.out.println("[MessageBeanImpl] 세터 setPhone 호출됨: " + phone);
	}

	public void setOutput(Output output) {
		this.output = output;
		System.out.println("[MessageBeanImpl] 세터 setOutput 호출됨: " + output);
	}

	@Override
	public void sayHello() {
		System.out.println("[MessageBeanImpl] sayHello 메서드 호출");
		
		String msg = name + "(" + phone +")님 안녕하세요.";
		
		try {
			output.print(msg);
			System.out.println("[MessageBeanImpl] sayHello 메서드 종료됨");
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
}
```
인적 사항과 Output 인터페이스를 필드로 갖는 빈 클래스를 구현. 전략을 필요에 따라 바꿔만 주면 얼마든 확장할 수 있음. 클래스를 직접 들고 있지 않아 Loosely Couplued를 지향

엔트리포인트 작성

```java
// sample6.Test
package springioc.sample6;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Test {

	public static void main(String[] args) {
		
		ApplicationContext context =
				new ClassPathXmlApplicationContext("applicationContext.xml", Output.class);
		
		MessageBean bean = context.getBean("myBean", MessageBean.class);
		
		bean.sayHello(); // 필드의 output에 어떤 클래스가 주입되는지에 따라 출력 디렉션이 정해짐
		
		((ClassPathXmlApplicationContext)context).close();
	}
}
```

이제 XML만 설정해주면 잘 작동할 것이다.

```xml
<!-- applicationContext.xml --> 
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:c="http://www.springframework.org/schema/c"
	xmlns:p="http://www.springframework.org/schema/p"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

	<bean id="consoleRef" class="springioc.sample6.ConsoleOutput" />
	
	<bean id="fileRef" class="springioc.sample6.FileOutput"
		c:filePath="~/text.txt" p:filePath="/home/limo/text.txt" /> <!-- 중복 지정됨. 일반적으로는 1번만 -->

<!-- 	<bean id="myBeanOld" class="springioc.sample6.MessageBeanImpl">
		<constructor-arg name="name" value="홍길동" />
		<property name="phone" value="010-1234-3456" />
		<property name="output" ref="myConsole"></property>
	</bean> -->

	<bean id="myBean" class="springioc.sample6.MessageBeanImpl"
		c:name="강감찬" p:phone="010-1232-3445" p:output-ref="consoleRef" />
		
	<bean id="anotherBean" class="springioc.sample6.MessageBeanImpl"
		c:name="신사임당" p:phone="010-1232-3445" p:output-ref="fileRef" />
</beans>
```

잘 작동한다. 두 개의 MessageBeanImpl 객체를 사용해보기 위해 Test.main을 수정하고 다시 테스트해보자.

```java
public static void main(String[] args) {
		System.out.println("컨텍스트 생성 시작");
		
		ApplicationContext context =
				new ClassPathXmlApplicationContext("applicationContext.xml", Output.class);
		
		System.out.println("컨텍스트 생성 완료\n");
		
		MessageBean bean1 = context.getBean("myBean", MessageBean.class);
		MessageBean bean2 = context.getBean("anotherBean", MessageBean.class);
		
		bean1.sayHello(); // 필드의 output에 어떤 클래스가 주입되는지에 따라 출력 디렉션이 정해짐
		bean2.sayHello();
		
		((ClassPathXmlApplicationContext)context).close();
	}
```

![60218772403d1e310b47141453336567.png](Assets/60218772403d1e310b47141453336567.png)

![03bd19280fb51f9e79381a45a72318bf.png](Assets/03bd19280fb51f9e79381a45a72318bf.png "03bd19280fb51f9e79381a45a72318bf.png")


## 실습: sample 7

앞으로는 이렇게 하지맙시다.

상위클래스와, 이를 상속받는 하위 클래스를 만든다.

```java
package springioc.sample7;

public class Emp { // 종업원을 표현하는 클래스

	private String name;
	private int salary;
	
	public Emp() {	
	}

	public Emp(String name, int salary) {
		super();
		this.name = name;
		this.salary = salary;
	}
	
}
```

```java
package springioc.sample7;

public class Developer extends Emp {

	private String dept;
	
	public Developer() {
	}

	public Developer(String name, int salary, String dept) {
		super(name, salary);
		this.dept = dept;
	}

	
}
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

	<bean id="developer" class="springioc.sample7.Developer">
		<constructor-arg index="0" value="홍길동"></constructor-arg>
		<constructor-arg index="1" type="int" value="5000"></constructor-arg>
		<constructor-arg index="2" value="개발1팀"></constructor-arg>
	</bean>
</beans>
```

문제 없어보이며, 실제로 기능에 문제가 없다. 그러나 두 클래스가 항상 붙어다닌다는 문제가 있다. 앞으로는 인터페이스 기반으로 주입하여 구현을 해보자.

```java
package springioc.sample7;

public class Engineer {

	private Emp emp; // 상속받지 않기 위해 필드로 잡는다.
	private String dept;
	
	public Engineer() {
	}

	public Engineer(Emp emp, String dept) {
		this.emp = emp;
		this.dept = dept;
	}
}
```

이렇게 하면 상속받지 않고도 상위 클래스의 속성과 기능을 사용할 수 있다. 그럼 XML 설정은 아래와 같이 해주면 된다.

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:c="http://www.springframework.org/schema/c"
	xmlns:p="http://www.springframework.org/schema/p"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

	<bean id="developer" class="springioc.sample7.Developer">
		<constructor-arg index="0" value="홍길동"></constructor-arg>
		<constructor-arg index="1" type="int" value="5000"></constructor-arg>
		<constructor-arg index="2" value="개발1팀"></constructor-arg>
	</bean>
	
	<bean id="emp" class="springioc.sample7.Emp"
		c:name="신사임당" c:salary="7000"/>
	
	<bean id="engineer" class="springioc.sample7.Engineer"
		c:dept="개발1팀" c:emp-ref="emp"/>
</beans>
```

이렇게 XML을 통해 관계를 일일이 잡아주면, 세세하고 정확하게 지정해줄 수 있다. 그러나 스케일이 커지고 복잡해지면 오류가 발생할 가능성이 높아진다. 또 오류를 잡기 어려워진다. 어떻게 하면 편하게 할 수 있을까? 자동으로 의존성을 주입해줄 수 있는 방법이 있다. ⇒ **Auto-Wiring**

## Auto-wiring

명시적 선언 없이도 자동으로 의존 Bean을 주입하는 기능이다. 앞으로는 이 기능을 사용할 것이다.

위와 같은 XML 설정은 의존 관계 파악이 용이하지만, 쓸게 너무 많아진다는 한계점이 있다. 결국 프로그램이 발전하면 관리가 힘들어지게 된다. Auto-wiring은 이를 보완한다.

### Auto-wiring의 방식

1. XML에서 빈 요소에 autowire 어트리뷰트를 지정
     - 1-1. autowire="byName"
         - byName: 빈의 식별자(id)를 가지고 자동 연결
     - 1-2. autowire="byType"
         - byType: 클래스 타입이 같은 객체를 자동 연결
2. @Autowired 어노테이션 사용
    - 컴포넌트 스캔 기능을 통해 자동 연결. 이때는 byType을 기반으로 주입.
    - XML에서 annotaion config가 들어감.


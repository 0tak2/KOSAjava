---
title: JavaScript 2
---

# 변수
## 변수 개요
CPU가 연산을 하려면 데이터가 필요하고, 데이터는 메모리 공간에 할당된다. 메모리란 메모리 셀의 집합이다.

컴퓨터는 메모리 셀의 용량 만큼 값을 읽고 지우고 넣는다. CPU가 연산할 때에는 해당 메모리 셀의 주소를 통해 직접 접근하겠으나, 개발자는 그 주소를 일일이 알 수 없다. 변수는 이때 특정 메모리 공간의 주소값을 몰라도 접근할 수 있도록 해당 메모리 공간에 이름을 붙여준 것이라고 할 수 있다. 이 이름을 변수 식별자라고 한다.

즉, 변수란 메모리 공간과 식별자를 맵핑한 것이라고 할 수 있다. 변수를 사용하기 위해서는 우선 변수를 선언해야 한다. 자바에서는 아래와 같이 했다.

```java
int num;
```

자바스크립트에서는 var, let, const 키워드 중 한 개를 적고, 변수의 식별자를 적어주면 된다. 원래 ES에는 var 키워드만 있었으나, ES6에 들어와 let과 const가 추가되었다. 차이는 다음과 같다.

- **var**: fnction level scope
- **let**, **const**: block level scope

var, let, const 외의 타입은 적어주지 않는다. 내부적으로 타입이 있지만, 선언시 지정할 필요가 없고, 한 번 초기화된 변수라 하더라도 다른 타입의 값을 재할당하는 것이 가능하다. (const 제외)  
이런 언어를 약타입 언어라고 한다.

## 호이스팅
```
호이스팅: 모든 변수 선언 구문이 해당 스코프 최상단으로 끌어올려진 것과 같은 효과를 만들어내는 현상을 말함
```

```js
// 변수 선언시 초기값
var result // result는 undefined로 초기화됨

// 호이스팅
console.log(result2); // undefined 출력. 에러가 발생하지 않음.
var result2 = 100
```

엔진이 자바스크립트 코드를 실행할 때, 두 개의 페이즈를 거치게 된다. 먼저 Creation Phase이다. 엔진은 우선 코드 전체를 훑으며 변수 선언이 있는지 찾고 메모리 공간에 식별자를 맵핑한다. 다음으로 Execution Phase이다. 코드의 처음으로 다시 돌아가 코드를 실제로 실행한다.  
따라서 초기화되지 않은 변수에 접근하더라도 오류가 발생하지 않는 것이다.

## var 스코프 연습
```js
/* --------------------------------------------------- */
/* 1. var 키워드를 통해 변수를 선언할 때
   같은 스코프 내에서는 동일 식별자로 중복 선언이 가능 */

var x = 100
var y = 200

var x = 300 // 오류 발생 없음. 식별자 중복시 var이 빠지게 됨. 즉, x = 300
var y // 식별자 중복시 초기화 구문이 없는 경우 무시됨.

console.log("1 / x: ", x, y); // 300 200


/* --------------------------------------------- */
/* 2. var 키워드를 통해 선언된 변수는
   function level scope 만을 local scope로 인정 */
var x = 1;

if (true) { // 함수가 아님 (동일 스코프)
    var x = 100; // var이 무시되고 x = 100
}

console.log("2 / x: ", x); // 100


/* --------------------------------------------- */
/* 3. 함수 */

// Java는 객체지향 언어. 함수가 없고 메서드만 있음
// JavaScript는 함수형 언어. 함수 존재.
// 함수: 특정 기능을 하는 코드를 하나의 단위로 묶어 반복적으로 사용
// function identifier(args) { /* statements */ }

var x = 1;

function myFunc() {
    var x = 200; // 다른 스코프 (새로운 function 내의 변수)
    console.log("myFunc / x: ", x);
}

console.log("3 / x: ", x); // ln 34
myFunc(); // ln 37

// Creation Phase에서 새로운 식별자 myFunc가 발견되고, 
// 메모리 공간에 myFunc가 undefined로 할당됨
// *자바스크립트에서 함수는 변수와 동일 취급

/*

+-------------------+----------------+-----------------------+
| 1                 | 2              | 3                     |
+-------------------+----------------+-----------------------+
| x: undefined      | -x-: undefined |                       |
+-------------------+----------------+-----------------------+
|                   | x: 1           |                       |
+-------------------+----------------+-----------------------+
| myFunc: undefined |                | -myFunc-: undefined   |
+-------------------+----------------+-----------------------+
|                   |                | myFunc: 코드와 바인딩 |
+-------------------+----------------+-----------------------+
|                   |                | -> { ... }            |
+-------------------+----------------+-----------------------+

#1
creation phase에서 각 식별자에 undefined 값이 할당

#2
excution phase에서 식별자에 바인딩된 메모리 공간에
값 할당을 시도
그러나 undefined는 immutable한 primitve 값이기 떄문에
값을 바꾸지 못하고 인근 메모리 공간에 값이 재할당되고
기존 식별자가 재바인딩

#3
myFunc 역시 creation phase와 
excution phase에서 변수처럼 취급되어 처리됨

-> 사용되지 않는 공간과 값은 가비지 콜렉터가 청소
*/
```

```js
// console.log(x); // Error!

x = 100; // Not Error! 암묵적 전역... 좋은 케이스는 아님

console.log(x);

function myFunc() {
    console.log(x);
    var x;
}

myFunc();
```

## let 스코프 연습
```js
// let
// ES6에서 도입
// block level scope 
// 기타 자바와 동일

let result = 100;
// let result = 50; // Error. 같은 스코프 내에서 중복 선언 불가

// 따라서 일반적인 상황에서는 var 대신 let을 쓰는 것이
// 오류를 방지하는데 도움이 된다

let num = 50

{
    let num = 100;
    let myVar = 10; // 블록이 끝나면 접근할 수 없음
}
console.log(num);
console.log(myVar); // Error.
```

```js
let i = 100 // i는 전역 변수. 스코프: ln 1 ~ END

function myFunc() {
    let i = 10 // i는 지역 변수. 스코프: 블록 내

    for (let i = 0; i<3; i++) { // i: 지역 변수. 스코프: for문 내
        console.log(i) // 0 1 2
    }

    console.log(10) // 10
}

myFunc();

console.log(i);
```

&nbsp;

let 변수의 호이스팅
```js
    // TDZ (Temporal Dead Zone): 호이스팅은 되었으나 사용 불가
console.log(x);
    // TDZ 끝
let x = 100;
// Error. 호이스팅은 발생하지만, let으로 선언되었으므로 에러 발생
// let 변수는 x를 초기화한 이후의 시점부터 사용 가능
```

&nbsp;

호이스팅은 var이든 let이든 const든 모두 일어나는 현상이다. 

```js
// 호이스팅은 var이든 let이든 const든 모두 일어나는 현상

let myVar = 1; // 전역변수. 블록 내에 갇히지 않음

{
    console.log(myVar); // 전역의 하위 스코프이므로 사용 가능
}

//

let myVar2 = 1;

{
    console.log(myVar2); // 지역변수가 호이스팅되어 오류 발생
    let myVar2 = 100; 
}
```

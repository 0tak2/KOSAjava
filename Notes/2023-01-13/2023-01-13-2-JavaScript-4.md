---
title: JavaScript 4
---

# 객체 Literal
JavaScript에서 객체를 생성하는 방법은 다양

그 중 객체 Literal: 객체를 만드는 가장 쉬운 방법

**객체 리터럴을 통한 객체 생성**
```js
{

} // -> empty 객체

// 안에 들어가는 것을 Property라고 한다
// 각 Property는 ','로 구분되어 다수가 들어갈 수 있다
// 하나의 Property는 'key_of_the_property: value_of_the_property'의 형태를 띈다

let myObj = {
    'name': '홍길동', // Property 1
    'age': 20, // Property 2
    'addr': '서울', // Property 3
    'myInfo': function() {
        console.log('소리 없는 아우성!');
    } // Property 4: 익명 함수. 이름 대신 키를 지정한 일반적인 형태
};

console.log(myObj.name); // 홀길동

console.log(myObj.myInfo); // [Function: myInfo]
myObj.myInfo(); // '소리 없는 아우성!'
```

&nbsp;

**객체의 접근 방법**
```java
let anotherObj2 = {
    name: '홍길동',
    10: 200
}
console.log(anotherObj2);
// { '10': 200, name: '홍길동' }
// 키는 문자열이기 떄문에, 수를 키로 지정하더라도
// 문자로 형변환되어 처리됨

// console.log(anotherObj2.10);
// console.log(anotherObj2.'10'); // 에러. '.' 연산자로 접근할 수 없음
console.log(anotherObj2['10']); // 대신 배열처럼 접근 가능. [연관배열] 인덱스로는 문자열을 정확히 넘겨야 함.
```
- 방법 1. obj.key
- 방법 2. obj['key']

&nbsp;

**동적 할당**
```js
let anotherObj2 = {
    name: '홍길동',
    10: 200
}
anotherObj2.address = '서울'; // 객체에 정의되지 않은 프로퍼티도 객체 외부에서 할당 가능

// Malfunction 가능성
let anotherObj3 = {
    name: '홍길동',
    address: '인천'
}
anotherObj3.addrass = '서울' // 오타 발생. 그러나 오류 발생되지 않고 새로운 프로퍼티 추가됨
```

개발자에게 자유성을 부여하면서도 의도되지 않은 동작이 발생할 가능성이 있다.


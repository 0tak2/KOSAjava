---
title: 1. 스프링 컨테이너
---

# 스프링 컨테이너

## 스프링 컨테이너의 여러 이름
**스프링 컨테이너**는 사실 **Application Context**라는 객체이다. 빈을 생성하고 빈 간의 관계를 설정하는 스프링의 핵심 작업을 수행한다. 빈의 생성과 관리를 전담하기 때문에 **빈 팩토리**라고 불리기도 한다. 컨테이너라고 지칭되는 것은 빈의 생성과 관리를 위해 빈을 가지고 있기 때문이다.

어제 작성했던 초반부의 프로그램을 보면 ConnectionMaker를 생성하고, UserDao에 인젝션하는 등 객체를 결정하고 생성하며 객체간 관계를 맺어주는 총체의 작업을 개발자가 직접 UserDaoTest의 main 메서드 내에 기술한다.

이후 팩토리를 도입하고 나서는, 팩토리에 객체 생성 및 관계 구성의 전권을 넘겨주게 되며, 해당 팩토리를 작성한 사람이 아니라면 그 동작 방식을 알지 못하더라도 UserDao를 사용하는데 어려움이 없다. 이를 객체에 대한 제어권을 이임한다는 의미로 IoC라고 불렀다.  
스프링 컨테이너는 팩토리처럼 IoC를 전담하는 엔진으로 이해할 수 있으며, 객체를 생성하고 인젝션하여 관계를 맺어주는 일을 알아서 해주게 된다. 이러한 측면에서 스프링 컨테이너를 **Spring IoC 컨테이너**, **Spring DI 컨테이너**라고 지칭하기도 한다.

## 빈

### 개요

그래서 정확히 빈이 무엇인가?

빈은 POJO(Plain Old Java Object)이다. 직역하자면 평범한 오래된 자바 오브젝트가 된다. 서블릿의 경우 특수한 클래스를 상속받는 과정을 통해 얻을 수 있기 때문에 POJO라고 할 수 없지만, 스프링 빈은 그냥 _평범한 자바 오프젝트_ 라는 것이다.  
그렇지만 우리가 직접 만들거나 관리할 수는 없고, 스프링 컨테이너에게 생성을 맡겨야 한다는 점이 특수한 것이다.

### 빈의 주요 속성

1. 클래스: 빈으로 등록할 자바 속성
2. ID: 각 빈을 구별하기 위한 식별자. 빈을 요청할 때에 사용할 수 있음
3. 스코프
    - singleton, prototype, …
    - 웹에 들어가기 전이기 때문에 위의 두 개만 알면 된다.
    - 어플리케이션 컨텍스트는 빈을 기본적으로 싱글톤으로 관리한다. 해당 객체가 단 한 번 생성됨을 보장한다는 것이다.
    - 프로토타입은 객체를 요청할 때 마다 새로 객체를 생성하여 반환한다.
    - 스프링은 주로 엔터프라이즈 환경에서 사용되기 때문에 기본값이 싱글톤이다. 대량의 요청이 들어올텐데 매 요청마다 객체를 생성하는 경우 부하가 막대할 것이기 떄문이다.
4. constructor-arg: 애플리케이션 컨텍스트에 의해 빈 객체가 생성될 때, 생성자에 전달할 인자
5. property: 위와 유사.  애플리케이션 컨텍스트에 의해 빈 객체가 생성될 때, setter에 전달할 인자

위와 같은 설정 정보를 애플리케이션 컨텍스트가 읽어 빈을 관리하게 된다. 이 설정 정보를 **Configuration Metadata**라고 한다.

기본적으로는 XML을 통해 만들 수 있다. XML을 사용하는 경우 한 문서에 모든 빈에 대한 정보와 관계가 나타나있다는 점이 장점이지만, 프로그램의 스케일이 커지는 경우 XML 자체를 관리하고 유지보수하는 것이 어려워진다는 문제가 있다.  
대안으로 어노테이션으로 설정을 할 수도 있다. 소스코드 내에 설정 정보가 삽입되기 때문에 어노테이션을 사용하면 편하다. 그러나 코드 전체에 설정 정보가 분산되기 때문에 다른 의미로 관리가 어려워진다는 문제가 있기도 하다. 일장일단이 있으니 상황에 맞게 사용할 것. XML과 어노테이션을 혼용할 수도 있다.

![18a556530ff58dbf64205041469fef2e.png](Assets/18a556530ff58dbf64205041469fef2e.png)

오늘의 실습에서는 어노테이션을 통해 스프링 빈 설정을 하고, 어제 실습 프로젝트에 스프링을 적용해도록 한다.

### 빈의 등록

> **빈을 등록한다?**  
> 
> 설정 정보를 컨테이너가 가져가서 빈을 만들기 위한 준비 작업을 마치는 것. 기본값은 준비를 마친 후 바로 객체를 작성하게 됨. 그러나 빈 생성의 타이밍도 지정할 수 있기 떄문에 빈을 등록했다고 해서 컨테이너 내에 빈이 존재하고 있다고 보장할 수는 없음.

빈을 등록하는 방법에는 두 가지가 있다.  
- 수동: 빈을 일일이 지정하여 어플리케이션 컨텍스트에 등록
- 자동: 컴포넌트 스캔을 통해 자동으로 빈을 어플리케이션 컨텍스트에 등록
    - 일반적으로 자동 방법이 더 편하기 떄문에 자동 방법 사용.
    - 그러나 수동으로 등록해야만 하는 때가 있음. 외부 라이브러리를 빈으로 등록하는 경우, 본인의 코드가 아니기 때문에 어노테이션을 붙일 수 없으므로 수동으로 등록함.
    - 따라서 두 방법 모두 알아놓아야 함.

#### 수동으로 빈 등록

**기본 꼴**

```java
class MyResource {
    // 이 클래스를 빈으로 등록하고 싶다면
    // 설정 클래스를 만들고 어노테이션을 만들어야 함
}

class MyResourceConfig {
    // 빈으로 등록할 클래스의 객체를 만드는 메서드
    public MyResource getResource() {
        return new MyResource();
    }
}
```

&nbsp;

**어노테이션 붙이기**

```java
class MyResource {
    // 
}

@Configuration
class MyResourceConfig {
    @Bean
    public MyResource getResource() {
        return new MyResource();
    }
}
```

@Bean과 함꼐 @Configuration 어노테이션을 잊으면 안된다.  

위와 같이 빈을 등록한 경우 MyResource가 빈의 이름/클래스이기는 하지만, 빈의 ID는 getResource가 된다. 메서드의 이름이 ID가 되는 것이다. 스코프는 기본값으로 싱글톤이며, 나머지 속성은 생성자나 setter가 없으므로 사용되지 않는다.

이렇게 설정 클래스를 수동으로 만들어 처리하는 방식과 반대로, @Component를 MyResource 클래스 바로 위에 붙이면 자동적으로 빈을 등록해준다.

이때 @Component를 상속받은 몇몇의 어노테이션이 있다.

- @Component
    - @Controller:컨트롤러 빈 등록
    - @Service:서비스 빈 등록
    - @Repositoy: DAO 빈 등록
    - @Configuration: 설정 빈 등록

위의 설정 클래스 MyResourceConfig도 @Component의 하위 클래스인 @Configuration에 의해 자동으로 애플리케이션 컨텍스트에 등록된다. 컨테이너는 설정 빈을 읽고, 내부의 @Bean 어노테이션을 참조하여 MyResource 클래스를 빈으로 등록하게 되는 것이다. 즉, 수동 방법이라고 하지만 사실 자동 방법과 수동 방법이 같이 사용되고 있다.

그렇다면 자동으로 등록된 MyResourceConfig 빈의 ID는 무엇이 될까? 바로 myResourceConfig가 된다. MyResourceConfig의 객체는 생성자인 MyResourceConfig의 호출을 통해 얻을 수 있으므로, 생성자의 이름 MyResourceConfig에서 딴 명칭이라고 생각하면 된다.

#### 자동으로 빈 등록

컴포넌트 스캔을 통해 특정 패키지 아래의 클래스를 모두 읽어 설정된 클래스를 빈으로 등록해줌

## STEP 8

### 방향 설정

Step 7 코드에서는 DaoFactory가 IoC 컨테이너의 역할을 하고 있다. UserDaoTest의 main에서 팩토리 객체를 생성하여, 팩토리로부터 dao를 얻고 있기 때문이다.

이 코드에 스프링 프레임워크를 적용하여, 팩토리를 스프링 IoC 컨테이너로 대체해보자.

### 메이븐 프로젝트로 전환

![fd3ca23d11c6c8868642e40af4ddd959.png](Assets/fd3ca23d11c6c8868642e40af4ddd959.png)


![90df1a69c743cbffc14cdea71ef3a794.png](Assets/90df1a69c743cbffc14cdea71ef3a794.png)

Maven - Update Project…

![69eb3e92592d78d141da28b89d222e1a.png](Assets/69eb3e92592d78d141da28b89d222e1a.png)

수동으로 추가했던 Connector/J 제거


&nbsp;

의존성 추가

![001ebaffc21350d57e4a3c7dcf3f8072.png](Assets/001ebaffc21350d57e4a3c7dcf3f8072.png)

pom.xml에 5.x 추가

![507d22e37a3bf5d91f3bafde04c35277.png](Assets/507d22e37a3bf5d91f3bafde04c35277.png)

pom.xml에 8.x 추가

### STEP 8 패키지 생성 및 STEP 7 소스코드 복사

step8.vo, step8.dao 생성 및 step7의 소스코드 복사. import 수정

step8.UserDaoTest 수정

```java
// 전략

       // 2\. DAO 생성  
//    ConnectionMaker connectionMaker = new SimpleMakeConnection(); // 의존성 제거를 위해 밖에서 생성  
//    UserDao dao = new UserDao(connectionMaker);  
//    UserDao dao = new DaoFactory().userDao();  
  
 // ApplicationContext 생성 후 UserDao 객체 요청  
   ApplicationContext context =  
            new AnnotationConfigApplicationContext(DaoFactory.class); // 어노테이션을 이용해 설정을 잡는 ApplicationContext  

    // UserDao dao = (UserDao) context.getBean("getUserDao");   
    UserDao dao = context.getBean("getUserDao", UserDao.class); // 클래스의 타입을 넘겨 캐스팅 생략 가능

// 후략
```

&nbsp;

그럼 빈으로 등록해줘야 하는 객체는 무엇일까? 우선 UserDao는 당연히 빈으로 등록해야하는 것처럼 보인다. 그런데 DaoFactory를 보면,  두 개의 객체를 만들어내고 있다.

userDao()는 UserDao 클래스의 객체를 반환하기 위해 connectionMaker()를 호출하여 ConnectionMaker 객체를 UserDao 생성자에 주입하고 있다. 따라서 ConnectionMaker 역시 빈으로 등록해줘야 한다.

```java
// DaoFactory
package step8.dao;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class DaoFactory {

	@Bean
	public UserDao userDao() {
		UserDao dao = new UserDao(connectionMaker());
		return dao;
	}
	
	@Bean
	public ConnectionMaker connectionMaker() {
		return new SimpleMakeConnection();
	}
}

```

```java
package step8;  
  
import org.springframework.context.ApplicationContext;  
import org.springframework.context.annotation.AnnotationConfigApplicationContext;  
import step8.dao.UserDao;  
import step8.vo.User;  
  
public class UserDaoTest {  
  
   public static void main(String\[\] args) throws Exception {  
        
      System.out.println("\[STEP8\]");  
        
      // 1\. 사용자 VO 생성  
   User user = new User("hong", "1234", "홍길동");  
        
      // 2\. DAO 생성
   ApplicationContext context =  
            new AnnotationConfigApplicationContext(DaoFactory.class);
   
       // 이하 코드는 잠시 주석 처리
}
```

실제로 두 개의 빈이 등록되고 생성되는지 확인하기 위해 생성자에 sysout을 찍어보자.

![4d93bddefbd8a4978d1c8c8d2d270c87.png](Assets/4d93bddefbd8a4978d1c8c8d2d270c87.png)

UserDao dao = context.getBean("userDao", UserDao.class);
를 추가하면 아래의 코드도 정상적으로 작동하게 된다.

![3f85c779dc02dd1884959f50c18abcc6.png](Assets/3f85c779dc02dd1884959f50c18abcc6.png)

예제 코드에 스프링 IoC 컨테이너를 성공적으로 적용하였다.

## 정말 싱글톤인가?

### STEP 7과 STEP 8 비교

step 7으로 들어가서, UserDao를 두 개 생성하게 한 다음, sout으로 출력해보자.

```java
       // 2\. DAO 생성
UserDao dao1 = new DaoFactory().userDao();  
UserDao dao2 = new DaoFactory().userDao();  

System.out.println(dao1);  
System.out.println(dao2);
```

![4d267213a5a760890fdba97226bc9cd8.png](Assets/4d267213a5a760890fdba97226bc9cd8.png)

해시코드가 다르다. 두 UserDao 객체는 다른 객체이다.

그럼 Step 8에서 UserDao를 ApplicationContext로부터 두 개 요청하여 sout 해보자.

```java
UserDao dao = context.getBean("userDao", UserDao.class); // 클래스의 타입을 넘겨 캐스팅 생략 가능  
UserDao dao2 = context.getBean("userDao", UserDao.class);

System.out.println(dao);  
System.out.println(dao2);
```

![15d086d800f2af1025345787d2721462.png](Assets/15d086d800f2af1025345787d2721462.png)

해시코드가 같다. 확실하게 UserDao 빈이 싱글톤으로 생성되었음을 확인할 수 있다. 사실 싱글톤을 구현하기 위해서는 자기 자신의 인스턴스를 필드로 갖는 일반적이지 않은 형태의 특수한 클래스를 작성해야한다. 그러나 ApplicationContext는 우리가 작성한 POJO 클래스를 별다른 처리를 하지 않아도 싱글톤으로 관리해주고 있는 것이다.  
이렇게 ApplicationContext의 주요 기능 중 하나가 Singleton Registry이다. 특별히 설정하지 않는 한 스프링 빈은 싱글톤 레지스트리에 등록되어 관리된다.

### 왜 싱글톤이 기본값인가?

스프링이 사용되는 환경을 생각해보라. 스프링은 보통 엔터프라이즈 환경에서 다중 이용자가 동시에 접속하는 서비스를 작성하는데 활용된다. 이 경우 여러 클라이언트가 하나의 객체를 공유하도록 설계하는 것이 효율적이다.

이전의 게시판 프로젝트의 경우, BoardService나 BoardDAO를 매번 new 키워드를 통해서 생성하였다. 그런데 이 경우 100명이 접속한다면 각 객체를 100개 이상 생성해야 한다. 아무리 GC이 잘 되더라도 서버의 부담이 심해질 것이다. 따라서 서비스나 Dao 객체를 공유하도록 싱글톤으로 구현하는 편이 퍼포먼스 면에서 효과적일 것이다.

다만 VO는 제외이다. 싱글톤으로 객체를 사용하기 위해서는 객체가 무상태(Stateless)여야 한다. 그러나 VO는 필연적으로 Stateful해야하기 때문에 싱글톤으로 관리하는 것이 불가능하며, 빈으로 등록하는 의미가 없다.



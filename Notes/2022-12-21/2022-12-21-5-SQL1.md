---
title: SQL1
---

원래는 그 다음 모델링을 공부해야 한다. 모델링이란 아주 쉽게 말하면 테이블과 테이블을 설계하는 작업을 말한다. 어떻게 하면 테이블을 더 잘 만들 수 있는지 공부하는 것이다.

도메인 분석 -> 데이터 모델링

그러나 지금 현재 상황에서 논의하는 것은 의미가 없다. 조금 DB에 익숙해진 후 다시 다뤄보겠다.  
우선은 SQL을 공부하면서 테이블을 다루는 방법을 공부한다.

# 상태 조회 구문
```sql
-- 대소문자 구분을 하지 않는다
-- 하지만 가독성을 위해 키워드는 대문자, 사용자 정의(테이블명, 스키마명, 컬럼명)는 소문자로 작성한다

-- 현재 계정이 접근할 수 있는 데이터베이스 조회
SHOW DATABASES;

-- 사용할 데이터베이스를 지정한다
USE employees;

-- 테이블 상태 조회
SHOW TABLE STATUS;

-- 특정 테이블 명세 조회
DESC departments;
```

# SELECT 구문
테이블(혹은 뷰)로부터 원하는 데이터를 추출, 조회

## 1. 기본 조회
```sql
-- 어떤 컬럼이 있는지 조회
DESC employees;

-- SELECT 컬럼명1, 컬렴명2, 컬럼명3 
SELECT first_name, last_name, birth_date FROM employees;
-- 실행시 결과 집합(Result Set)이 리턴된다.
-- 혹은 Result Grid, 결과 레코드 집합 등이라고 부르기도 한다.
-- 이때 결과 집합도 하나의 테이블'처럼' 간주할 수 있다. 실제 디스크에 저장된 데이터는 아니므로 실제 테이블과는 다르다.
```

## 2. AS: Alias 이용
만약 결과 집합의 컬럼명을 바꾸고자 한다면 Alias를 이용하면 된다.  
Alias: 별칭.

```sql
SELECT first_name AS '이름 (First Name)', -- 공백이나 특수문자는 '...'
        last_name AS '성 (Last Name)',
        birth_date AS 생년월일
        FROM employees;
-- 실행 결과
-- +-------------------+----------------+------------+
-- | 이름 (First Name) | 성 (Last Name) | 생년월일   |
-- +-------------------+----------------+------------+
-- | Georgi            | Facello        | 1953-09-02 |
-- | Bezalel           | Simmel         | 1964-06-02 |
-- | Parto             | Bamford        | 1959-12-03 |
-- | Chirstian         | Koblick        | 1954-05-01 |
-- | Kyoichi           | Maliniak       | 1955-01-21 |
-- +-------------------+----------------+------------+
-- 5 rows in set (0.00 sec)
```

## 3. 실습 환경 구성
잠시 실습을 위해 아래의 SQL 스크립트를 실행한다.

[12.21_create_schema.sql](../../Assets/2022-12-21%20데이터베이스%20실습/12.21_create_schema.sql)

```
PS > cd 다운로드
PS > mysql -uroot -p
mysql> source 12.21_create_schema.sql
```

명령을 통해 잘 실행되었는지 확인한다.

```sql
SHOW DATABASES; -- 잘 실행되었는지 확인
-- +--------------------+
-- | Database           |
-- +--------------------+
-- | ...                |
-- | sqldb              |
-- | ...                |
-- +--------------------+
-- 7 rows in set (0.00 sec)

USE sqldb; -- 스키마 변경

SHOW TABLES;
-- +-----------------+
-- | Tables_in_sqldb |
-- +-----------------+
-- | buytbl          |
-- | usertbl         |
-- +-----------------+
-- 2 rows in set (0.00 sec)
```

또한 다음의 SQL 스크립트를 실행하여 값을 입력해준다.

[12.21_insert_data.sql](../../Assets/2022-12-21%20데이터베이스%20실습/12.21_insert_data.sql)

다만, 이 파일은 한글이 포함되어 CLI 클라이언트에서 source 명령으로 입력이 잘 되지 않는다.  
워크벤치에서 열어서, sqldb 스키마를 선택 후, 스크립트를 실행해준다.

완료되면 SELECT 문을 통해 값을 확인해본다.

```
+--------+--------+-----------+------+---------+---------+--------+------------+
| userID | name   | birthYear | addr | mobile1 | mobile2 | height | mDate      |
+--------+--------+-----------+------+---------+---------+--------+------------+
| BBK    | 바비킴 |      1973 | 서울 | 010     | 0000000 |    176 | 2013-05-05 |
| EJW    | 은지원 |      1972 | 경북 | 011     | 8888888 |    174 | 2014-03-03 |
| JKW    | 조관우 |      1965 | 경기 | 018     | 9999999 |    172 | 2010-10-10 |
```

SQL 스크립트와 다르게 실제 테이블에는 userID가 알파벳 오름차순임을 알 수 있다. 이는 userID가 PK로 지정되어있기 떄문이다.

## 4. WHERE: 조건 지정
### (1) 이름이 김경호인 사람의 모든 정보 출력
```sql
SELECT * FROM usertbl WHERE name='김경호';
-- 다만, 컬럼을 name과 같이 SQL 키워드로 지정하는 것은 좋지 않다.

-- 실행 결과
-- +--------+--------+-----------+------+---------+---------+--------+------------+
-- | userID | name   | birthYear | addr | mobile1 | mobile2 | height | mDate      |
-- +--------+--------+-----------+------+---------+---------+--------+------------+
-- | KKH    | 김경호 |      1971 | 전남 | 019     | 3333333 |    177 | 2007-07-07 |
-- +--------+--------+-----------+------+---------+---------+--------+------------+
-- 1 row in set (0.00 sec)
```

### (2) 1970년 이후 출생했고 신장이 182 이상인 사람의 아이디와 이름 조회
```sql
SELECT userID, name
FROM usertbl
WHERE (birthYear >= 1970) AND (height >= 182);
-- AND의 연산자 우선순위가 비교연산자보다 낮기 때문에 괄호는 생략 가능

-- 실행 결과
-- +--------+--------+
-- | userID | name   |
-- +--------+--------+
-- | LSG    | 이승기 |
-- | SSK    | 성시경 |
-- +--------+--------+
-- 2 rows in set (0.00 sec)
```

### (3) 키가 180에서 183사이인 사람의 이름과 아이디 조회
```sql
SELECT userID, name
FROM usertbl
WHERE (height >= 180) AND (height <= 183);


-- 혹은 BETWEEN A AND B를 사용
-- 이 경우 A와 B가 결과에 포함 (이상, 이하)
SELECT userID, name
FROM usertbl
WHERE height BETWEEN 180 AND 183;


-- 실행 결과
-- +--------+--------+
-- | userID | name   |
-- +--------+--------+
-- | LJB    | 임재범 |
-- | LSG    | 이승기 |
-- +--------+--------+
-- 2 rows in set (0.00 sec)
```

### (4) 지역이 경남, 전남, 경북인 사람의 이름과 지역 조회
```sql
SELECT name, addr
FROM usertbl
WHERE (addr = '경남') OR (addr = '전남') OR (addr = '경북');


-- 혹은 IN 연산자 사용
SELECT name, addr
FROM usertbl
WHERE addr IN ('경남', '전남', '경북');

-- 실행 결과
-- +--------+------+
-- | name   | addr |
-- +--------+------+
-- | 은지원 | 경북 |
-- | 김범수 | 경남 |
-- | 김경호 | 전남 |
-- | 윤종신 | 경남 |
-- +--------+------+
-- 4 rows in set (0.00 sec)
```

## 5. LIKE: 패턴매칭
### (1) 와일드카드
**% 와 _**
- %: 0개 이상의 문자열
  - 자바%
    - Matched: 자바, 자바1, 자바프로그래밍
    - 자바로 시작하는 모든 문자열이 매치됨
  - %자바%
    - Matched: 자바, 열혈자바프로그래밍, 솔트룩스자바교육
    - 자바라는 문자열이 포함된 모든 문자열
- _: **1개** 문자
  - 자바_
    - Matched: 자바킹, 자바왕, 자바섬
    - 자바로 시작하는 3글자의 문자열
  - 자바__
    - Matched: 자바대왕, 자바커피
    - 자바로 시작하는 4글자의 문자열
- 와일드카드 비교는 =가 아니라 LIKE 연산자를 통해 할 수 있음

### (2) 김씨 성을 가진 사람들의 이름과 키를 조회
```sql
SELECT name, height FROM usertbl WHERE name LIKE '김%';

-- 실행 결과
-- +--------+--------+
-- | name   | height |
-- +--------+--------+
-- | 김범수 |    173 |
-- | 김경호 |    177 |
-- +--------+--------+
-- 2 rows in set (0.00 sec)
```

## 6. 서브쿼리
### (1) 김경호보다 키가 크거나 같은 사람의 이름과 키를 조회
우리가 배운 방법으로 하면 다음과 같이 조회할 수 있다.
```sql
SELECT height FROM usertbl WHERE name = '김경호';

-- 실행 결과
-- +--------+
-- | height |
-- +--------+
-- |    177 |
-- +--------+
-- 1 row in set (0.00 sec)

SELECT name, addr FROM usertbl WHERE height >= 177;

-- 실행 결과
-- +--------+------+
-- | name   | addr |
-- +--------+------+
-- | 김경호 | 전남 |
-- | 임재범 | 서울 |
-- | 이승기 | 서울 |
-- | 성시경 | 서울 |
-- +--------+------+
-- 4 rows in set (0.00 sec)
```

여기서 더 간단하게 서브쿼리를 이용할 수도 있다.

```sql
SELECT name, addr
FROM usertbl
WHERE height >= (SELECT height
                 FROM usertbl
                 WHERE name = '김경호');

-- 실행 결과
-- +--------+------+
-- | name   | addr |
-- +--------+------+
-- | 김경호 | 전남 |
-- | 임재범 | 서울 |
-- | 이승기 | 서울 |
-- | 성시경 | 서울 |
-- +--------+------+
-- 4 rows in set (0.00 sec)
```

괄호 안의 쿼리가 먼저 실행되고, 받아온 값을 합쳐 질의하게 된다.

### (2) 지역이 경남인 사람의 키보다 크거나 같은 사람의 이름과 키을 조회
```sql
-- SELECT name, height
-- FROM usertbl
-- WHERE height >= (SELECT height
--                  FROM usertbl
--                  WHERE addr = '경남');
-- 위와 같이 조회하면 서브쿼리의 결과셋이 한 개 이상이므로 오류 발생
-- 실행 결과
-- ERROR 1242 (21000): Subquery returns more than 1 row

-- 문제의 명제 자체가 ILLEGAL 하지만,
-- 지역이 경남인 어떤 사람의 키보다 크거나 같은 사람을 조회하는 경우,
-- ANY를 사용할 수 있음
SELECT name, height
FROM usertbl
WHERE height >= ANY (SELECT height
                     FROM usertbl
                     WHERE addr = '경남');

-- 지역이 경남인 모든 사람의 키보다 크거나 같은 사람을 조회하는 경우,
-- ALL을 사용할 수 있음
SELECT name, height
FROM usertbl
WHERE height >= ALL (SELECT height
                     FROM usertbl
                     WHERE addr = '경남');
```

## 7. ORDER BY: 정렬
ORDER BY는 하나의 SQL문에서 가장 마지막에 위치한다.  
정렬 순서의 기본값은 오름차순이다.  
정렬은 서버의 부하를 가중시키기 때문에 필요한 경우에만 사용하는 것이 좋다.

### (1) 먼저 가입한 순서대로 회원의 이름과 가입일을 출력

```sql
SELECT name, mdate
FROM usertbl
ORDER BY mdate;

-- 실행 결과
-- +--------+------------+
-- | name   | mdate      |
-- +--------+------------+
-- | 윤종신 | 2005-05-05 |
-- | 김경호 | 2007-07-07 |
-- | 이승기 | 2008-08-08 |
-- | 조용필 | 2009-04-04 |
-- | 임재범 | 2009-09-09 |
-- | 조관우 | 2010-10-10 |
-- | 김범수 | 2012-04-04 |
-- | 바비킴 | 2013-05-05 |
-- | 성시경 | 2013-12-12 |
-- | 은지원 | 2014-03-03 |
-- +--------+------------+
-- 10 rows in set (0.00 sec)

-- 정렬 순서의 기본값은 오름차순이므로 옛날 날짜부터 조회된다.

-- 이 조건을 명시적으로 지정하려면, ASC를 이용한다.
SELECT name, mdate
FROM usertbl
ORDER BY mdate ASC;
```

### (2) 최근 가입한 순서대로 회원의 이름과 가입일을 출력

```sql
SELECT name, mdate
FROM usertbl
ORDER BY mdate DESC;

-- 실행 결과
-- +--------+------------+
-- | name   | mdate      |
-- +--------+------------+
-- | 은지원 | 2014-03-03 |
-- | 성시경 | 2013-12-12 |
-- | 바비킴 | 2013-05-05 |
-- | 김범수 | 2012-04-04 |
-- | 조관우 | 2010-10-10 |
-- | 임재범 | 2009-09-09 |
-- | 조용필 | 2009-04-04 |
-- | 이승기 | 2008-08-08 |
-- | 김경호 | 2007-07-07 |
-- | 윤종신 | 2005-05-05 |
-- +--------+------------+
-- 10 rows in set (0.00 sec)

-- ORDER BY에 DESC를 지정하면 내림차순으로 정렬된다.
```

### (3) 회원의 이름과 가입일, 키를 키가 큰 순서로 정렬하여 출력

```sql
SELECT name, mdate, height
FROM usertbl
ORDER BY height DESC;

-- 실행 결과
-- +--------+------------+--------+
-- | name   | mdate      | height |
-- +--------+------------+--------+
-- | 성시경 | 2013-12-12 |    186 |
-- | 임재범 | 2009-09-09 |    182 |
-- | 이승기 | 2008-08-08 |    182 |
-- | 김경호 | 2007-07-07 |    177 |
-- | 바비킴 | 2013-05-05 |    176 |
-- | 은지원 | 2014-03-03 |    174 |
-- | 김범수 | 2012-04-04 |    173 |
-- | 조관우 | 2010-10-10 |    172 |
-- | 윤종신 | 2005-05-05 |    170 |
-- | 조용필 | 2009-04-04 |    166 |
-- +--------+------------+--------+
-- 10 rows in set (0.00 sec)

-- 다만 키가 같은 사람(임재범, 이승기)이 존재한다.
```

### (3) 2차 정렬: (2)와 같이 정렬하되, 키가 같은 사람이 있으면 가입일이 빠른 순서로 정렬

2차 정렬이란, 전체 결과셋이 아닌, 동률 데이터에 한하여 다시 정렬하는 방법이다.
ORDER BY 다음에 정렬 기준을 콤마로 나열하여 구현할 수 있다.

```sql
SELECT name, mdate, height
FROM usertbl
ORDER BY height DESC, mdate ASC;

-- 실행 결과
-- +--------+------------+--------+
-- | name   | mdate      | height |
-- +--------+------------+--------+
-- | 성시경 | 2013-12-12 |    186 |
-- | 이승기 | 2008-08-08 |    182 |
-- | 임재범 | 2009-09-09 |    182 |
-- | 김경호 | 2007-07-07 |    177 |
-- | 바비킴 | 2013-05-05 |    176 |
-- | 은지원 | 2014-03-03 |    174 |
-- | 김범수 | 2012-04-04 |    173 |
-- | 조관우 | 2010-10-10 |    172 |
-- | 윤종신 | 2005-05-05 |    170 |
-- | 조용필 | 2009-04-04 |    166 |
-- +--------+------------+--------+
-- 10 rows in set (0.00 sec)

-- 먼저 가입한 이승기가 임재범보다 위에 위치하고 있음을 볼 수 있다.
```
## 8. DISTINCT: 중복 제거
### (1) 회원들의 거주 지역이 어디인지 조회
```sql
SELECT addr from usertbl;
-- 실행 결과
-- +------+
-- | addr |
-- +------+
-- | 서울 |
-- | 경북 |
-- | 경기 |
-- | 경기 |
-- | 경남 |
-- | 전남 |
-- | 서울 |
-- | 서울 |
-- | 서울 |
-- | 경남 |
-- +------+
-- 10 rows in set (0.00 sec)

-- 지역이 잘 출력되었으나, 중복 데이터를 배제하는 것이 문제의 의도에 합당해보인다.

SELECT DISTINCT addr from usertbl;
-- 실행 결과
-- +------+
-- | addr |
-- +------+
-- | 서울 |
-- | 경북 |
-- | 경기 |
-- | 경남 |
-- | 전남 |
-- +------+
-- 5 rows in set (0.00 sec)

-- DISTINCT를 이용하여 중복 데이터를 제거하였다.
```

## 9. LIMIT: 원하는 개수의 데이터만 조회
### (1) 가입일이 오래된 사람들 3명을 출력
```sql
SELECT * FROM usertbl ORDER BY mDate ASC LIMIT 3;

-- 실행 결과
-- +--------+--------+-----------+------+---------+---------+--------+------------+
-- | userID | name   | birthYear | addr | mobile1 | mobile2 | height | mDate      |
-- +--------+--------+-----------+------+---------+---------+--------+------------+
-- | YJS    | 윤종신 |      1969 | 경남 | NULL    | NULL    |    170 | 2005-05-05 |
-- | KKH    | 김경호 |      1971 | 전남 | 019     | 3333333 |    177 | 2007-07-07 |
-- | LSG    | 이승기 |      1987 | 서울 | 011     | 1111111 |    182 | 2008-08-08 |
-- +--------+--------+-----------+------+---------+---------+--------+------------+
-- 3 rows in set (0.00 sec)
```

# 테이블의 복사
서브 쿼리를 응용하여 테이블을 쉽게 복사할 수 있다.

```sql
CREATE TABLE usertbl2(
  SELECT * FROM usertbl
);
-- 괄호 안에 컬럼명과 데이터 타입 대신
-- SELECT 문을 넣으면, 질의 결과를 안에 입력하게 된다.
```

다만 제약사항은 복사되지 않는다는 문제가 있다.

제약사항: Primary Key, Foreign Key, Not NULL 등
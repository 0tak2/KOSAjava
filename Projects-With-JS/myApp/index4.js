/* --------------------------------------------------- */
/* 1. var 키워드를 통해 변수를 선언할 때
   같은 스코프 내에서는 동일 식별자로 중복 선언이 가능 */

var x = 100
var y = 200

var x = 300 // 오류 발생 없음. 식별자 중복시 var이 빠지게 됨. 즉, x = 300
var y // 식별자 중복시 초기화 구문이 없는 경우 무시됨.

console.log("1 / x: ", x, y); // 300 200


/* --------------------------------------------- */
/* 2. var 키워드를 통해 선언된 변수는
   function level scope 만을 local scope로 인정 */
var x = 1;

if (true) { // 함수가 아님 (동일 스코프)
    var x = 100; // var이 무시되고 x = 100
}

console.log("2 / x: ", x); // 100


/* --------------------------------------------- */
/* 3. 함수 */

// Java는 객체지향 언어. 함수가 없고 메서드만 있음
// JavaScript는 함수형 언어. 함수 존재.
// 함수: 특정 기능을 하는 코드를 하나의 단위로 묶어 반복적으로 사용
// function identifier(args) { /* statements */ }

var x = 1;

function myFunc() {
    var x = 200; // 다른 스코프 (새로운 function 내의 변수)
    console.log("myFunc / x: ", x);
}

console.log("3 / x: ", x); // ln 34
myFunc(); // ln 37

// Creation Phase에서 새로운 식별자 myFunc가 발견되고, 
// 메모리 공간에 myFunc가 undefined로 할당됨
// *자바스크립트에서 함수는 변수와 동일 취급

/*
+-------------------+----------------+-----------------------+
| 1                 | 2              | 3                     |
+-------------------+----------------+-----------------------+
| x: undefined      | -x-: undefined |                       |
+-------------------+----------------+-----------------------+
|                   | x: 1           |                       |
+-------------------+----------------+-----------------------+
| myFunc: undefined |                | -myFunc-: undefined   |
+-------------------+----------------+-----------------------+
|                   |                | myFunc: 코드와 바인딩 |
+-------------------+----------------+-----------------------+
|                   |                | -> { ... }            |
+-------------------+----------------+-----------------------+

#1
creation phase에서 각 식별자에 undefined 값이 할당

#2
excution phase에서 식별자에 바인딩된 메모리 공간에
값 할당을 시도
그러나 undefined는 primitve 값이기 떄문에 immutable 하므로
값을 바꾸지 못함. 따라서 인근 메모리 공간에 값이 재할당되고
식별자가 재바인딩

#3
myFunc 역시 creation phase와 
excution phase에서 변수처럼 취급되어 처리됨

-> 사용되지 않는 공간과 값은 가비지 콜렉터가 청소
*/